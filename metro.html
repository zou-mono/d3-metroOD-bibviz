<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>Title</title>    <!--<script src="js/d3.min.js" type="text/javascript"></script>-->    <link rel="stylesheet" href="css/main.css"/>    <script src="https://d3js.org/d3.v5.min.js" type="text/JavaScript"></script>    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.8/d3.min.js" type="text/JavaScript"></script>--></head><body><svg height="500" id="station-chart" width="1200"></svg><div id="selected"> Hover over a line or bar to show more info about a contradiction, chapter or book.</div><script>    var bData = null;    var bookToChapter = {};    var bookToChapterCount = {};    var maxLength = 250;    var contra = null;    var contraFilters = {        source: window._contraSource ? window._contraSource : 'sab', /* Source of data, default SAB */        book: null,         /* Specific book name */        chapter: null,      /* Specific absolute chapter */        type: null,         /* Specific contradiction type */        search: null,       /* Text to search for via regex */        refCount: null,     /* Specific range of references */        crossBook: false,   /* Only show cross-book contradictions */        colorize: 'Crimson' /* Colorize the arcs */    };    if (!window.maxArcs) {        var maxArcs = 10;    }    // Available contradiction types    var contraTypeFilters = {        'All': null,        'Count': /(how (many|old))|(sixth)/i,        'People': /(^\s*who)|(whom)|(whose)|(sons? of)|(mother)|(father)|(offspring)|(genealogy)|(related)/i,        'Time': /(^\s*when)|(what day)|(which came first)/i,        'Location': /(where)|(road)|(mountain)|(from the)/i,        'Death': /(heaven)|(hell)|(die)|(death)|(lifespan)|(congregation of the lord)|(live long)/i,        'Love': /(marry)|(marriage)|(love)|(sex)|(homosexual)|(conceive)|(wife)|(childbearing)|(adulterer)/i,        'God': /god/i,        'Jesus': /jesus/i,        'Other': null    };    // Returns true if a new tab should be opened from a click    function newTab() {        return (window.event && ((event.which == 1 && (event.ctrlKey === true || event.metaKey === true) || (event.which == 2))));    }    function getAbsoluteChapter(verse) {        var parts = /^(\d?\s?[a-z]+)[\s.:]*(\d*):?(\d*)[-]?(\d*)/i.exec(verse);        //console.log(parts);        if (parts === null) return;        var chapter = bookToChapter[parts[1]];        chapter = (chapter === undefined) ? bookToChapter[parts[1] + 's'] : chapter;        return chapter + parseInt(parts[2]);    }    // Chooses a color for an arc from start to end    function colorize(start, end) {        var color = 'crimson';        var distance;        if (contraFilters.colorize == 'Rainbow') {            distance = Math.abs(end - start);            color = d3.hsl(distance / 1189 * 360, 0.7, 0.35);        }        return color;    }    /*        Make sure we have a flat list of refs to filter or render.        This handles the following two cases and returns a flat,        plain list:        ['Ref 1', 'Ref 2', ...]        {            'Some desc': ['Ref 1', 'Ref 2'],            'Another': ['Ref 3', ...]        }    */    function flatRefs(refs) {        var i, j, keys;        if (refs instanceof Array) {            refList = refs;        } else {            // This is an object with more info, so let's pull            // out all the refs.            refList = [];            keys = Object.keys(refs);            for (i = 0; i < keys.length; i++) {                for (j = 0; j < refs[keys[i]].length; j++) {                    refList.push(refs[keys[i]][j]);                }            }        }        return refList;    }    function renderContra() {        var textSearch = null;        if (contraFilters.search) {            textSearch = new RegExp(contraFilters.search, 'gi');        }        var chart = d3.select('#contradictions-chart')            .selectAll('.arc')            .data(contra[contraFilters.source].contradictions.filter(function (d) {                    var i, found, match, refList;                    refList = flatRefs(d.refs);                    // Filter out items that don't touch this chapter                    if (contraFilters.chapter !== null) {                        found = false;                        for (i = 0; i <= Math.min(refList.length - 1, 10); i++) {                            if (getAbsoluteChapter(refList[i]) == contraFilters.chapter) {                                found = true;                                break;                            }                        }                        if (!found) {                            return false;                        }                    }                    // Filter out items that don't touch this book                    if (contraFilters.book !== null) {                        found = false;                        for (i = 0; i < Math.min(refList.length - 1, 10); i++) {                            match = /(\d?\s*\w+)/.exec(refList[i]);                            if (match && (match[1] == contraFilters.book || match[1] + 's' == contraFilters.book)) {                                found = true;                                break;                            }                        }                        if (!found) {                            return false;                        }                    }                    // Filter out the wrong type of item                    var regex;                    if (contraFilters.type !== null) {                        if (contraFilters.type == 'Other') {                            // Exclude any of the listed types except 'All' and 'Other'                            var keys = Object.keys(contraTypeFilters);                            for (i = 0; i < keys.length; i++) {                                regex = contraTypeFilters[keys[i]];                                if (regex && regex.test(d.desc)) {                                    return false;                                }                            }                        } else {                            // Include only this type                            regex = contraTypeFilters[contraFilters.type];                            if (regex && !regex.test(d.desc)) {                                return false;                            }                        }                    }                    if (textSearch !== null) {                        if (!textSearch.test(d.desc)) {                            return false;                        }                    }                    return true;                }),                // Key function to compare values on insert/update/remove                function (d) {                    return d.desc;                });        chart.enter().append('g')            .attr('class', 'arc')            .on('click', function (d) {                var url = '/' + slugg(d.desc) + '-' + contraFilters.source + '.html';                //var url = 'http://www.skepticsannotatedbible.com/contra/' + d.url;                // Handle [cmd/ctrl]+click and middle click to open a new tab                if (newTab()) {                    window.open(url);                } else {                    window.location = url;                }            })            .on('mouseover', function (d) {                var refList = flatRefs(d.refs);                d3.select('#contradictions-chart')                    .selectAll('.arc')                    .sort(function (a, b) {                        return (a == d) ? 1 : -1;                    });                d3.select('#selected')                    .html(d.desc + '<br/><span class="subdued">' + refList.join(', ').substr(0, maxLength) + '</span>');            })            .each(function (d, i) {                var group = d3.select(this);                var refList = flatRefs(d.refs);                if (refList.length > 1) {                    // Only show up to 10 refs, some have over 100...                    for (x = 0; x <= Math.min(maxArcs, refList.length - 2); x++) {                        var start = getAbsoluteChapter(refList[x]);                        var end = getAbsoluteChapter(refList[x + 1]);                        if (start > end) {                            var tmp = end;                            end = start;                            start = tmp;                        }                        var r = (end - start) * 0.51;                        var ry = Math.min(r, 490);                        if (!isNaN(start) && !isNaN(end) && !isNaN(r) && !isNaN(ry)) {                            var path = 'M ' + start + ',399 A ' + r + ',' + ry + ' 0 0,1 ' + end + ',399 ';                            group.append('path')                                .attr('d', path)                                .style('stroke', function (start, end) {                                    return colorize(start, end);                                }(start, end));                        }                    }                }            });        chart.exit()            .transition()            .duration(350)            .style('opacity', 0)            .remove();        // Update any highlighting from filters        d3.select('#contradictions-chart')            .selectAll('rect')            .classed('selected', false);        if (contraFilters.book !== null) {            d3.select('#contradictions-chart')                .selectAll('.b' + contraFilters.book.replace(/\s+/g, '').toLowerCase())                .classed('selected', true);        }    }    d3.select('#selected').transition().delay(7000).duration(1000).style('opacity', 1.0);    d3.csv('data/station_flow.csv').then(function (data) {        bData = data;        var svg = d3.select('#station-chart');        var maxFLOW = d3.max(data, d => parseInt(d.IN_FLOW));        var minFLOW = d3.min(data, d => parseInt(d.IN_FLOW));        var yScale = d3.scaleLinear().domain([minFLOW,maxFLOW]).range([0,100]);        svg.selectAll('rect')            .data(data)            .enter().append('rect')            .attr('x', function (d, i) {                return i*10;            })            .attr('y', 400)            .attr('width', 10)            .attr('height', d => yScale(parseInt(d.IN_FLOW)))            .on('mouseover', function (d) {                /*contraFilters.book = null;                contraFilters.chapter = getAbsoluteChapter(d.book + ' ' + d.chapter.name.split(' ')[1]);                renderContra();*/                d3.select('#selected')                    .html(d.ZDMC + '<br/><span class="subdued">' +                        d.IN_FLOW);            });    });</script></body></html>